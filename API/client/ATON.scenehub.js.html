<!-- start:source.tmpl.hbs -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
		<title>ATON.scenehub.js</title>
		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<link href="https://fonts.googleapis.com/css?family=PT+Mono" rel="stylesheet">
		<link type="text/css" rel="stylesheet" href="css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="css/prism.min.css">
		<link type="text/css" rel="stylesheet" href="css/template.min.css">
		<script type="text/javascript">
			window.TEMPLATE_OPTIONS = {"includeDate":true,"dateFormat":"Do MMM YYYY","systemName":"ATON 3.0 API","systemSummary":"ATON is a framework to create Web3D apps (presenters, applied games, tools, etc…) interacting with CH objects and 3D scenes on the Web. It adopts a 'develop once, deploy everywhere' approach, without requiring any installation for final users, with its front-end automatically adapting to the device (mobile, desktop/kiosk or immersive VR).","systemLogo":"img/logo-inv-40x40.png","systemColor":"","navMembers":[{"kind":"class","title":"Classes","summary":"All documented classes."},{"kind":"external","title":"Externals","summary":"All documented external members."},{"kind":"global","title":"Globals","summary":"All documented globals."},{"kind":"mixin","title":"Mixins","summary":"All documented mixins."},{"kind":"interface","title":"Interfaces","summary":"All documented interfaces."},{"kind":"module","title":"Modules","summary":"All documented modules."},{"kind":"namespace","title":"Namespaces","summary":"All documented namespaces."},{"kind":"tutorial","title":"Tutorials","summary":"All available tutorials."}],"footer":"","copyright":"FooDoc Copyright © 2016 The contributors to the JSDoc3 and FooDoc projects.","linenums":true,"collapseSymbols":true,"inverseNav":true,"inlineNav":false,"outputSourceFiles":false,"sourceRootPath":null,"disablePackagePath":true,"outputSourcePath":false,"showTableOfContents":true,"showAccessFilter":true,"analytics":null,"methodHeadingReturns":true,"sort":"linenum, longname, version, since","search":true,"favicon":null,"stylesheets":[],"scripts":[],"monospaceLinks":false,"cleverLinks":false};
			window.DOCLET_TOC_ENABLED = false;
			window.DOCLET_AFILTER_ENABLED = false;
		</script>
</head>
<body>
	<!-- start:navbar.hbs -->
	<header class="navbar navbar-default navbar-fixed-top navbar-inverse">
		<div class="container">
			<div class="navbar-header">
				<a class="navbar-brand branding-logo" href="index.html" style="background-image: url(img/logo-inv-40x40.png);">
					ATON 3.0 API
				</a>
				<!-- displayed on small devices -->
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>
			<div class="navbar-collapse collapse" id="topNavigation">
				<ul class="nav navbar-nav">
								<li class="dropdown">
									<a href="list_class.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="Button.html">Button</a></li>
											<li><a href="Label.html">Label</a></li>
											<li><a href="LightProbe.html">LightProbe</a></li>
											<li><a href="Node.html">Node</a></li>
											<li><a href="POV.html">POV</a></li>
									</ul>
								</li>
								<li class="dropdown">
									<a href="list_namespace.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="ATON.html">ATON</a></li>
											<li><a href="AudioHub.html">AudioHub</a></li>
											<li><a href="EventHub.html">EventHub</a></li>
											<li><a href="FE.html">FE</a></li>
											<li><a href="MatHub.html">MatHub</a></li>
											<li><a href="MediaRec.html">MediaRec</a></li>
											<li><a href="Nav.html">Nav</a></li>
											<li><a href="SceneHub.html">SceneHub</a></li>
											<li><a href="SemFactory.html">SemFactory</a></li>
											<li><a href="SUI.html">SUI</a></li>
											<li><a href="Utils.html">Utils</a></li>
											<li><a href="VRoadcast.html">VRoadcast</a></li>
											<li><a href="XR.html">XR</a></li>
									</ul>
								</li>
				</ul>
					<!-- start:lunr-search-navbar.hbs -->
					<form class="navbar-form navbar-right" role="search">
						<div class="input-group">
							<input type="text" class="form-control" placeholder="Search" id="lunr-search-input">
							<div class="input-group-btn">
								<button class="btn btn-default" id="lunr-search-submit">
									<i class="glyphicon glyphicon-search"></i>
								</button>
							</div>
						</div>
					</form>
					<!-- start:lunr-search-navbar.hbs -->		</div>
		</div>
	</header>
	<!-- end:navbar.hbs -->		<div class="page-header">
			<div class="container">
				<span class="kind">source</span>
				<h1><span class="name">ATON.scenehub.js</span></h1>
			</div>
		</div>
	<div class="container content">
		<div class="row">
			<div class="col-md-12 main-content">
		<section class="source-section">
			<article></article>
			<pre class="prettyprint source language-javascript line-numbers"><code class="language-javascript">/*
    ATON Scene Hub
    scene JSON routines

    author: bruno.fanini_AT_gmail.com

===========================================================*/

/**
ATON Scene Hub
@namespace SceneHub
*/
let SceneHub = {};

SceneHub.MODE_ADD = 0;
SceneHub.MODE_DEL = 1;

SceneHub.FLOAT_PREC = 5;

/**
Initializes the component
*/
SceneHub.init = ()=>{
    SceneHub.currID   = undefined; // Scene ID (sid) - FIXME: rename to "SID"
    SceneHub.currData = undefined; // holds compact object describing our ATON scene
    SceneHub._bEdit   = false;     // edit mode (client can modify json on the server)

    SceneHub._bLoading = false;

    // Current scene title &amp; description
    SceneHub._title = undefined;
    SceneHub._descr = undefined;

    SceneHub.initBaseParsers();
};

/**
This enables/disables edit mode - i.e. changes to the scene are sent to server and become persistent
@param {bool} b - true or false
@example
ATON.SceneHub.setEditMode(true)
*/
SceneHub.setEditMode = (b)=>{
    SceneHub._bEdit = b;
    console.log("Edit mode:"+b);
};


/**
    Loads a scene by providing JSON path
    @param {string} reqpath - JSON url
    @param {string} sid - Scene ID
    @param {function} oncomplete - Function to be called on complete
    @example
        ATON.SceneHub.load("http://path/to/scene.json", "sample", ()=>{ console.log("Done!"); });
*/
SceneHub.load = (reqpath, sid, oncomplete)=>{
    //let args = reqpath.split(',');

    SceneHub._bLoading = true;
    console.log("Loading Scene: "+sid);

    return $.getJSON( reqpath, ( data )=>{
        SceneHub.currData  = data;
        SceneHub.currID    = sid; //scenejson.substring(scenejson.lastIndexOf('/')+1);
        SceneHub._bLoading = false;

        //console.log(ATON.currScene);

        SceneHub.parseScene(data);

        if (oncomplete) oncomplete();
        ATON.fireEvent("SceneJSONLoaded", sid);
    });
};

SceneHub.parseScene = (sobj)=>{
    sobj = (sobj === undefined)? SceneHub.currData : sobj;
    if (sobj === undefined) return;

    for (let k in sobj)
        if (SceneHub._jsonParsers[k]) SceneHub._jsonParsers[k]( sobj[k] );
};

SceneHub.getJSONchildren = (nid, type)=>{
    if (type === undefined) type = ATON.NTYPES.SCENE;

    let P = undefined;
    let children = [];

    if (type === ATON.NTYPES.SEM)   P = ATON.getSemanticNode(nid);
    if (type === ATON.NTYPES.SCENE) P = ATON.getSceneNode(nid);

    if (P === undefined) return undefined;

    for (let c in P.children){
        let child = P.children[c];

        if (child.nid !== undefined) children.push( child.nid );
        }

    return children;
};

SceneHub.getJSONgraphEdges = (type)=>{
    if (type === undefined) type = ATON.NTYPES.SCENE;
    let nodes = ATON.snodes;
    
    if (type === ATON.NTYPES.SEM) nodes = ATON.semnodes;
    if (type === ATON.NTYPES.UI)  nodes = ATON.uinodes;

    let edges = {};

    for (let n in nodes){
        let N = nodes[n];

        //if (N &amp;&amp; N.children) edges[n] = SceneHub.getJSONchildren(n, type);

        let E = {};
        if (N &amp;&amp; N.parent &amp;&amp; N.parent.nid){
            //edges.push([N.parent.nid, N.nid]);
            if (edges[N.parent.nid] === undefined) edges[N.parent.nid] = [];
            edges[N.parent.nid].push(N.nid);
            //edges[N.parent.nid].filter((v,i) => edges[N.parent.nid].indexOf(v) === i);
        }
    }

    //console.log(edges);
    return edges;
};

SceneHub.getJSONsemanticSpheresList = (semid)=>{
    let S = ATON.getSemanticNode(semid);
    if (S === undefined) return undefined;

    let SL = [];

    for (let s in S.children){
        let sphere = S.children[s];
        if (sphere.type){
            SL.push([
                parseFloat(sphere.position.x.toPrecision(SceneHub.FLOAT_PREC)), 
                parseFloat(sphere.position.y.toPrecision(SceneHub.FLOAT_PREC)), 
                parseFloat(sphere.position.z.toPrecision(SceneHub.FLOAT_PREC)), 
                parseFloat(sphere.scale.x.toPrecision(SceneHub.FLOAT_PREC))
            ]);
        }
    }

    return SL;
};

SceneHub.getJSONsemanticConvexShapes = (semid)=>{
    let S = ATON.getSemanticNode(semid);
    if (S === undefined) return undefined;

    let CL = [];

    for (let s in S.children){
        let semesh = S.children[s];
        if (semesh.userData._convexPoints){
            CL.push(semesh.userData._convexPoints);
        }
    }

    //console.log(CL);
    
    return CL;
};

// Top-level scene-JSON parsers
SceneHub.initBaseParsers = ()=>{
    SceneHub._jsonParsers = {};

    // Scene Title &amp; Description
    SceneHub._jsonParsers.title = (title)=>{
        if (title === undefined) return;

        SceneHub.setTitle(title);
    };

    SceneHub._jsonParsers.description = (descr)=>{
        if (descr === undefined) return;

        SceneHub.setDescription(descr);
    };

    // Environment
    SceneHub._jsonParsers.environment = (env)=>{

        let pano = env.mainpano;
        if (env.mainpano){
            if (pano.url) ATON.setMainPanorama(ATON.PATH_COLLECTION+pano.url);
            if (pano.rotation) ATON.setMainPanoramaRotation(pano.rotation);
        }

        let L = env.mainlight;
        if (L){
            if (L.direction) ATON.setMainLightDirection( new THREE.Vector3(L.direction[0],L.direction[1],L.direction[2]) );

            if (ATON._dMainL){
                if (L.color)     ATON._dMainL.color = new THREE.Color(L.color[0],L.color[1],L.color[2]);
                if (L.intensity) ATON._dMainL.intensity = L.intensity;

                if (L.shadows !== undefined) ATON.toggleShadows(L.shadows);
                else ATON.toggleShadows(false);
            }
            else {
                //ATON.toggleShadows(false);
                ATON.toggleMainLight(false);
            }
        }
        else {
            //ATON.toggleShadows(false);
            ATON.toggleMainLight(false);
        }

        let lps = env.lightprobes;
        if (lps){
            if (lps.auto) ATON.setAutoLP(true);
        }

        if (env.exposure) ATON.setExposure(env.exposure);

    };

    // NavMode
    SceneHub._jsonParsers.navmode = (navmode)=>{
        if (navmode === undefined) return;

        ATON.Nav.setNavMode(navmode);
    };

    // Measurements
    SceneHub._jsonParsers.measurements = (M)=>{
        if (M === undefined) return;

        for (let m in M){
            let measure = M[m];

            if (measure.points &amp;&amp; measure.points.length === 6){
                let A = new THREE.Vector3(
                    parseFloat(measure.points[0]),
                    parseFloat(measure.points[1]),
                    parseFloat(measure.points[2])
                );
                let B = new THREE.Vector3(
                    parseFloat(measure.points[3]),
                    parseFloat(measure.points[4]),
                    parseFloat(measure.points[5])
                );
                ATON.SUI.addMeasurementPoint(A);
                ATON.SUI.addMeasurementPoint(B);
            }
        }
    };

    // Viewpoints
    SceneHub._jsonParsers.viewpoints = (povs)=>{
        if (povs === undefined) return;

        for (let p in povs){
            let pov = povs[p];
            
            if (p === "home"){
                ATON.Nav.setHomePOV( 
                    new ATON.POV()
                    .setPosition(pov.position[0],pov.position[1],pov.position[2])
                    .setTarget(pov.target[0],pov.target[1],pov.target[2])
                    .setFOV(pov.fov)
                );
            }
            else {
                new ATON.POV(p)
                .setPosition(pov.position)
                .setTarget(pov.target)
                .setFOV(pov.fov)
                //.setKeywords(pov.keywords);
            }
        }
    };

    // Visible scene-graph
    SceneHub._jsonParsers.scenegraph = (sg)=>{
        if (sg === undefined) return;

        let nodes = sg.nodes;
        let edges = sg.edges;

        // nodes
        for (let nid in nodes){
            let N = nodes[nid]; // JSON node

            //let G = ATON.createSceneNode(nid); // ATON node
            let G = ATON.getOrCreateSceneNode(nid).removeChildren();
            
            // load models by urls list
            let urls = N.urls;
            if (urls){
                if (Array.isArray(urls)){
                    urls.forEach(u => {
                        ATON.createSceneNode().load(ATON.PATH_COLLECTION+u).attachTo(G);
                    });
                }
                else {
                    G.load(ATON.PATH_COLLECTION+urls);
                }
            }

            // FIXME: not working
            if (N.shadowcast)    G.setShadowCast(N.shadowcast);
            if (N.shadowreceive) G.setShadowCast(N.shadowreceive);

            if (N.toYup) G.setYup();

            //if (N.nopicking){ G.disablePicking(); } // FIXME: not working
/*
            if (N.color){
                let C = ATON.MatHub.colors[N.color];

                G.setMaterial( new THREE.MeshBasicMaterial({ 
                    color: C, 
                    transparent: true,
                    depthWrite: false, 
                    opacity: 0.1,
                }));

                console.log(G);
            }
*/
            // Keywords
            if (N.keywords) G.kwords = N.keywords;

            // Transform node
            let transform = N.transform;
            if (transform){
                if (transform.position) G.setPosition(transform.position[0],transform.position[1],transform.position[2]);
                if (transform.rotation) G.setRotation(transform.rotation[0],transform.rotation[1],transform.rotation[2]);
                if (transform.scale)    G.setScale(transform.scale[0],transform.scale[1],transform.scale[2]);
            }
/*
            if (N.show !== undefined){
                if (N.show){ G.show(); console.log("show "+nid); }
                else { G.hide(); console.log("hide "+nid); }
            }
*/
        }

        // Build graph through relationships
        for (let parid in edges){
            let children = edges[parid];

            let P = ATON.getSceneNode(parid);

            if (P !== undefined){
                for (let c in children){
                    let childid = children[c];
                    let C = ATON.getSceneNode(childid);
                    if (C !== undefined) C.attachTo(P);
                }
            }
        }

        // After connection
        for (let nid in nodes){
            let N = nodes[nid]; // JSON node
            let G = ATON.getSceneNode(nid);

            if (G !== undefined){ 
                if (N.show !== undefined){
                    //console.log(N.show);

                    if (N.show){ G.show(); console.log("show "+nid); }
                    else { G.hide(); console.log("hide "+nid); }
                    //console.log(ATON.getSceneNode(nid));
                }

                if (N.nopicking){ G.disablePicking(); }

                if (N.material){
                    let mat = new THREE.MeshStandardMaterial(N.material);
                    G.setMaterial( mat );
                }
            }
        }

/*
        for (let e = 0; e &lt; edges.length; e++){
            let E = edges[e];

            let from = E[0];
            let to   = E[1];

            if (from &amp;&amp; to){
                let child = ATON.getSceneNode(to);
                if (child) child.attachTo(from);
            }
        }
*/
    };

    // Semantic scene-graph
    SceneHub._jsonParsers.semanticgraph = (sg)=>{
        if (sg === undefined) return;

        let nodes = sg.nodes;
        let edges = sg.edges;

        // nodes
        for (let nid in nodes){
            let N = nodes[nid]; // JSON node

            //let G = ATON.createSemanticNode(nid);
            let G = ATON.getOrCreateSemanticNode(nid).removeChildren();
            
            // load shapes by urls list
            let urls = N.urls;
            if (urls){
                if (Array.isArray(urls)){
                    urls.forEach(u => {
                        ATON.createSemanticNode().load(ATON.PATH_COLLECTION+u).attachTo(G);
                    });
                }
                else {
                    G.load(ATON.PATH_COLLECTION+urls);
                }
            }

            if (N.toYup) G.setYup();

            if (N.description) G.setDescription(N.description);
            if (N.audio) G.setAudio(N.audio);

            // Keywords
            if (N.keywords) G.kwords = N.keywords;

            // Sphere [x,y,z, r]
            let spheres = N.spheres;
            if (Array.isArray(spheres)){
                for (let s in spheres){
                    let S = spheres[s];
                    let loc = new THREE.Vector3(parseFloat(S[0]),parseFloat(S[1]),parseFloat(S[2]));
                    ATON.SemFactory.createSphere(nid, loc, parseFloat(S[3]));
                }
            }

            let convexshapes = N.convexshapes;
            if (Array.isArray(convexshapes)){
                for (let s in convexshapes){
                    let S = convexshapes[s];

                    let points = [];
                    for (let i=0; i&lt;S.length; i+=3){
                        let p = new THREE.Vector3(S[i],S[i+1],S[i+2]);
                        points.push(p);
                    }

                    ATON.SemFactory.createConvexShape(nid, points);
                }

            }
        }

        // Build relationships
        for (let parid in edges){
            let children = edges[parid];

            let P = ATON.getSemanticNode(parid);

            if (P !== undefined){
                for (let c in children){
                    let childid = children[c];
                    let C = ATON.getSemanticNode(childid);
                    if (C !== undefined) C.attachTo(P);
                }
            }
        }

        // After connection
        for (let nid in nodes){
            let N = nodes[nid]; // JSON node
            let G = ATON.getSemanticNode(nid);

            if (G !== undefined){
                if (N.show !== undefined){
                    //console.log(N.show);

                    if (N.show){ G.show(); console.log("show "+nid); }
                    else { G.hide(); console.log("hide "+nid); }
                    //console.log(ATON.getSemanticNode(nid));
                }

                if (N.nopicking){ G.disablePicking(); }

                if (N.material){
                    let mat = new THREE.MeshStandardMaterial(N.material);
                    G.setMaterial( mat );
                }
            }
        }

/*
        for (let e = 0; e &lt; edges.length; e++){
            let E = edges[e];

            let from = E[0];
            let to   = E[1];

            if (from &amp;&amp; to){
                let child = ATON.getSemanticNode(to);
                if (child) child.attachTo(from);
            }
        }
*/
    };

};

// Adds custom scene parser to extend JSON scene
// parser(key){ ... }
SceneHub.addSceneParser = (key, parser)=>{
    SceneHub._jsonParsers[key] = parser;
};

// [C] Sends JSON edit to server node
// previously used: https://tools.ietf.org/html/rfc6902
SceneHub.sendEdit = (patch, mode, onComplete)=>{
    if (SceneHub._bLoading || !SceneHub._bEdit) return;
    if (patch === undefined) return;
    if (mode === undefined) mode = SceneHub.MODE_ADD;

    let sid = SceneHub.currID;

    let O = {};
    O.sid  = sid;
    O.data = patch;
    O.mode = (mode === SceneHub.MODE_DEL)? "DEL" : "ADD";

    let jstr = JSON.stringify(O);
    //console.log(jstr);

    $.ajax({
        url: ATON.PATH_RESTAPI+"edit/scene",
        type:"POST",
        data: jstr,
        contentType:"application/json; charset=utf-8",
        dataType:"json",

        // Update local scene JSON
        // TODO: improve traffic by applying patch to local json, and NOT by receiving entire JSON 
        success: (r)=>{
            if (r === undefined) return;
            //console.log(r);
            SceneHub.currData = r;
            //console.log(ATON.currSceneHub.data);

            if (onComplete) onComplete();
        }
    });
};

SceneHub.setTitle = (title)=>{
    SceneHub._title = title;
};
SceneHub.getTitle = ()=>{
    return SceneHub._title;
}

SceneHub.setDescription = (descr)=>{
    SceneHub._descr = descr;
};
SceneHub.getDescription = ()=>{
    return SceneHub._descr;
};


export default SceneHub;</code></pre>
		</section>
			</div>
		</div>
	</div>
	<footer>
				<div class="copyright">FooDoc Copyright © 2016 The contributors to the JSDoc3 and FooDoc projects.</div>
			<div class="generated-by">Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on 1st Feb 2021 using the <a href="https://github.com/steveush/foodoc">FooDoc template</a>.</div>
	</footer>
	<script src="js/jquery.min.js"></script>
	<script src="js/bootstrap.min.js"></script>
	<script src="js/clipboard.min.js"></script>
	<script src="js/prism.min.js"></script>
	<script src="js/template.min.js"></script>
		<!-- start:lunr-search-modal.hbs -->
		<div class="modal fade" id="lunr-search-modal">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
						<h4 class="modal-title">Search results</h4>
					</div>
					<div class="modal-body" id="lunr-search-body">
					</div>
					<div class="modal-footer" id="lunr-search-footer">
						<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
					</div>
				</div><!-- /.modal-content -->
			</div><!-- /.modal-dialog -->
		</div>
		<!-- end:lunr-search-modal.hbs -->		<script src="js/lunr.min.js"></script>
	
</body>
</html>
<!-- end:source.tmpl.hbs -->